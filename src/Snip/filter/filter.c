/*******************************************************************************
  * @file                   filter.c
  * @Author:                MQjehovah                 mail:MQjehovah@hotmail.com
  * @version                1.0.0
  * @date                   2016.5.25
  * @brief					滤波算法
  ******************************************************************************
  * @attention
*******************************************************************************/
/* Includes ------------------------------------------------------------------*/
#include "filter.h"
/* Definition ----------------------------------------------------------------*/

/* Functions -----------------------------------------------------------------*/
/*******************************************************************************
  * @brief  限幅滤波法
  * @param  None
  * @retval None
  * @Note   确定两次采样允许的最大偏差值（设为A）每次检测到新值时判断：
			如果本次值与上次值之差<=A,则本次值有效。
			如果本次值与上次值之差>A,则本次值无效,放弃本次值,用上次值代替本次值
			优点：能有效克服因偶然因素引起的脉冲干扰
			缺点：无法抑制那种周期性的干扰平滑度差
*******************************************************************************/
u16 LimitingFilter(u16 value)
{
	static u16 last_value;
	if ((value - last_value < A) && (last_value - value < A))
		last_value =  value;
	return last_value;
}

/*******************************************************************************
  * @brief  中值滤波法
  * @param  None
  * @retval None
  * @Note   连续采样N次（N取奇数）把N次采样值按大小排列取中间值为本次有效值
			优点：能有效克服因偶然因素引起的波动干扰
				  对温度、液位的变化缓慢的被测参数有良好的滤波效果
			缺点：对流量、速度等快速变化的参数不宜
*******************************************************************************/
/* N值可根据实际情况调整 */
/* 排序采用冒泡法 */
//#define N  11
u16 MedianFilter(u16 value_buf[],u8 N)
{
	bubble_sort(value_buf,N);
	return value_buf[(N-1)/2];
}     

void bubble_sort(int a[],int n)//n为数组a的元素个数
{
    //一定进行N-1轮比较
    for(int i=0; i<n-1; i++)
    {
        //每一轮比较前n-1-i个，即已排序好的最后i个不用比较
        for(int j=0; j<n-1-i; j++)
        {
            if(a[j] > a[j+1])
            {
                int temp = a[j];
                a[j] = a[j+1];
                a[j+1]=temp;
            }
        }
    }
}
//优化实现
void bubble_sort_better(int a[],int n)//n为数组a的元素个数
{
    //最多进行N-1轮比较
    for(int i=0; i<n-1; i++)
    {
        bool isSorted = true;
        //每一轮比较前n-1-i个，即已排序好的最后i个不用比较
        for(int j=0; j<n-1-i; j++)
        {
            if(a[j] > a[j+1])
            {
                isSorted = false;
                int temp = a[j];
                a[j] = a[j+1];
                a[j+1]=temp;
            }
        }
        if(isSorted) break; //如果没有发生交换，说明数组已经排序好了
    }
}

/*******************************************************************************
  * @brief  算术平均滤波法
  * @param  None
  * @retval None
  * @Note   连续取N个采样值进行算术平均运算
			N值较大时：信号平滑度较高，但灵敏度较低
			N值较小时：信号平滑度较低，但灵敏度较高
			N值的选取：一般流量，N=12；压力：N=4
			优点：适用于对一般具有随机干扰的信号进行滤波
				  这样信号的特点是有一个平均值，信号在某一数值范围附近上下波动
			缺点：对于测量速度较慢或要求数据计算速度较快的实时控制不适用比较浪费RAM
*******************************************************************************/
//#define N 12
u16 AlgorithmAverageFilter(u16 value_buf[],u8 N)
{
   u16  sum = 0;
   for (u8 i=0;i<N;i++)
   {
      sum + = value_buf[i];
   }
   return u16(sum/N);
}

/*******************************************************************************
  * @brief  递推平均滤波法（又称滑动平均滤波法）
  * @param  None
  * @retval None
  * @Note   把连续取N个采样值看成一个队列,队列的长度固定为N
			每次采样到一个新数据放入队尾,并扔掉原来队首的一次数据.(先进先出原则)
			把队列中的N个数据进行算术平均运算,就可获得新的滤波结果
			N值的选取：流量，N=12；压力：N=4；液面，N=4~12；温度，N=1~4
			优点：对周期性干扰有良好的抑制作用，平滑度高适用于高频振荡的系统
			缺点：灵敏度低,对偶然出现的脉冲性干扰的抑制作用较差
				  不适用于由于脉冲干扰所引起的采样值偏差,比较浪费RAM
*******************************************************************************/
//#define N 12
u16 value_buf[N];
u16 RecursiveAverageFilter(u16 value)
{
	u8 i;
	u16 sum;
	for(i=0;i<N-1;i++)
		value_buf[i] = value_buf[i+1];
	value_buf[N-1] = value();
	for (i=0;i<N;i++) 
		sum += value_buf[i];
	return u16(sum/N);
}

/*******************************************************************************
  * @brief  中位值平均滤波法（又称防脉冲干扰平均滤波法）
  * @param  None
  * @retval None
  * @Note   相当于“中位值滤波法”+“算术平均滤波法”连续采样N个数据，
			去掉一个最大值和一个最小值然后计算N-2个数据的算术平均值
			优点：融合了两种滤波法的优点对于偶然出现的脉冲性干扰，
				  可消除由于脉冲干扰所引起的采样值偏差
			缺点：灵敏度低,对偶然出现的脉冲性干扰的抑制作用较差
				  测量速度较慢，和算术平均滤波法一样比较浪费RAM
*******************************************************************************/
//#define N 12
u16 MedianAverageFilter(u16 value)
{
   char count,i,j;
   char value_buf[N];
   int  sum=0;
   for  (count=0;count 
   {
      value_buf[count] = get_ad();
      delay();
   }
   for (j=0;j 
   {
      for (i=0;i 
      {
         if ( value_buf>value_buf[i+1] )
         {
            temp = value_buf;
            value_buf = value_buf[i+1];
             value_buf[i+1] = temp;
         }
      }
   }
   for(count=1;count 
		sum += value[count];
   return (char)(sum/(N-2));
}

/*******************************************************************************
  * @brief  限幅平均滤波法
  * @param  None
  * @retval None
  * @Note   相当于“限幅滤波法”+“递推平均滤波法” 每次采样到的新数据先进行限幅处理
			再送入队列进行递推平均滤波处理
			优点：融合了两种滤波法的优点
				  对于偶然出现的脉冲性干扰，可消除由于脉冲干扰所引起的采样值偏差
			缺点：比较浪费RAM
*******************************************************************************/
//#define N 12
u16 value_buf[N];
u16 LimitingAverageFilter(u16 value)
{
	//
}

/*******************************************************************************
  * @brief  一阶滞后滤波法(低通数字滤波)
  * @param  None
  * @retval None
  * @Note   本次滤波结果=（1-a）*本次采样值+a*上次滤波结果(a=0~1)
			优点：对周期性干扰具有良好的抑制作用适用于波动频率较高的场合
			缺点：相位滞后，灵敏度低滞后程度取决于a值大小不能消除滤波频率高于采样频率的1/2的干扰信号
*******************************************************************************/
u16 LagFilter(u16 value)
{
	static u16 last_value;
	last_value = a*value + (1-a)*last_value;	//简化计算可以将系数a扩大一定倍数变成整数
	return last_value;
}

/*******************************************************************************
  * @brief  加权递推平均滤波法
  * @param  None
  * @retval None
  * @Note   是对递推平均滤波法的改进，即不同时刻的数据加以不同的权
			通常是，越接近现时刻的资料，权取得越大
			给予新采样值的权系数越大，则灵敏度越高，但信号平滑度越低
			优点：适用于有较大纯滞后时间常数的对象和采样周期较短的系统
			缺点：对于纯滞后时间常数较小，采样周期较长，变化缓慢的信号不能迅速反应系统当前所受干扰的严重程度，
				  滤波效果差
*******************************************************************************/
//#define N 12
/* coe数组为加权系数表，存在程序存储区。*/
char code coe[N] = {1,2,3,4,5,6,7,8,9,10,11,12};
char code sum_coe = 1+2+3+4+5+6+7+8+9+10+11+12;
char filter()
{
   char count;
   char value_buf[N];
   int  sum=0;
   for (count=0,count 
   {
      value_buf[count] = get_ad();
      delay();
   }
   for (count=0,count 
      sum += value_buf[count]*coe[count];
   return (char)(sum/sum_coe);
}

/*******************************************************************************
  * @brief  消抖滤波法
  * @param  None
  * @retval None
  * @Note   设置一个滤波计数器将每次采样值与当前有效值比较：
			如果采样值＝当前有效值，则计数器清零如果采样值<>当前有效值，则计数器+1，
			并判断计数器是否>=上限N(溢出)如果计数器溢出,则将本次值替换当前有
			效值,并清计数器
			优点：对于变化缓慢的被测参数有较好的滤波效果,可避免在临界值附近控制器的反复开/关跳动或显示器上数值抖动
			缺点：对于快速变化的参数不宜如果在计数器溢出的那一次采样到的值恰好是干扰值,则会将干扰值当作有效值
*******************************************************************************/
//#define N 12
char filter1()
{
   char count="0";
   char new_value;
   new_value = get_ad();
   while (value !=new_value);
   {
      count++;
      if (count>=N)   return new_value;
       delay();
      new_value = get_ad();
   }
   return value;
}

/*******************************************************************************
  * @brief  限幅消抖滤波法
  * @param  None
  * @retval None
  * @Note   相当于“限幅滤波法”+“消抖滤波法”先限幅后消抖
			优点：继承了“限幅”和“消抖”的优点改进了“消抖滤波法”中的某些缺陷,避免将干扰值导入系统
			缺点：对于快速变化的参数不宜
*******************************************************************************/
//#define N 12
u16 filter2()
{
	return 0;
}

/*******************************************************************************
  * @brief  IIR数字滤波器
  * @param  None
  * @retval None
  * @Note   确定信号带宽，滤之。
			Y(n) = a1*Y(n-1) + a2*Y(n-2) + ... + ak*Y(n-k) + b0*X(n) + b1*X(n-1) + b2*X(n-2) + ... + bk*X(n-k)
			优点：高通，低通，带通，带阻任意。设计简单(用matlab）
			缺点：运算量大
*******************************************************************************/
u16 IIRFilter()
{
	return 0;
}

/*******************************************************************************
  * @brief  卡尔曼滤波
  * @param  None
  * @retval None
  * @Note   Q:过程噪声，Q增大，动态响应变快，收敛稳定性变坏
			R:测量噪声，R增大，动态响应变慢，收敛稳定性变好  
*******************************************************************************/
double KalmanFilter(const double ResrcData, double ProcessNiose_Q, double MeasureNoise_R)
{
	static double x_last;
	static double p_last;
	//double InitialPrediction;		//???
    double R = MeasureNoise_R;
    double Q = ProcessNiose_Q;
    double x_mid = x_last;
    double x_now;
    double p_mid ;
    double p_now;
    double kg;

    x_mid=x_last;						//x_last=x(k-1|k-1),x_mid=x(k|k-1)
    p_mid=p_last+Q;						//p_mid=p(k|k-1),p_last=p(k-1|k-1),Q=噪声
    kg=p_mid/(p_mid+R);					//kg为kalman filter，R为噪声
    x_now=x_mid+kg*(ResrcData-x_mid);	//估计出的最优值
    p_now=(1-kg)*p_mid;					//最优值对应的covariance
	
    p_last = p_now;						//更新covariance值
    x_last = x_now;						//更新系统状态值

    return x_now;               
}

#endif
/*********************************END OF FILE**********************************/
